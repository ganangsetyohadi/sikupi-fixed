-- Sikupi Database Schema - Complete Current Version
-- Updated to reflect all migrations through 009_auth_profile_management.sql
-- This schema represents the complete current state of the database
-- Includes: core tables, notifications system, auth profile management, and all RLS policies

CREATE TYPE "product_kind" AS ENUM (
  'ampas',
  'turunan'
);

CREATE TYPE "product_category" AS ENUM (
  'ampas_kopi',
  'briket',
  'pulp',
  'scrub',
  'pupuk',
  'pakan_ternak',
  'lainnya'
);

CREATE TYPE "coffee_type" AS ENUM (
  'arabika',
  'robusta',
  'mix',
  'unknown'
);

CREATE TYPE "grind_level" AS ENUM (
  'halus',
  'sedang',
  'kasar',
  'unknown'
);

CREATE TYPE "condition" AS ENUM (
  'basah',
  'kering',
  'unknown'
);

CREATE TYPE "order_status" AS ENUM (
  'new',
  'pending_payment',
  'paid',
  'packed',
  'shipped',
  'completed',
  'cancelled'
);

CREATE TYPE "user_role" AS ENUM (
  'admin',
  'buyer'
);

CREATE TYPE "notification_type" AS ENUM (
  'order_update',
  'payment_confirmed', 
  'shipment_ready',
  'ai_analysis',
  'admin_alert',
  'system_message'
);

-- Profiles table (extends Supabase auth.users)
CREATE TABLE "profiles" (
  "id" uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  "full_name" text,
  "phone" text,
  "role" user_role NOT NULL DEFAULT 'buyer',
  "created_at" timestamp with time zone NOT NULL DEFAULT NOW(),
  "updated_at" timestamp with time zone NOT NULL DEFAULT NOW()
);

-- Products table
CREATE TABLE "products" (
  "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "kind" product_kind NOT NULL,
  "category" product_category NOT NULL,
  "sku" text UNIQUE,
  "title" text NOT NULL,
  "slug" text UNIQUE,
  "description" text,
  "coffee_type" coffee_type NOT NULL DEFAULT 'unknown',
  "grind_level" grind_level NOT NULL DEFAULT 'unknown',
  "condition" condition NOT NULL DEFAULT 'unknown',
  "price_idr" bigint NOT NULL CHECK (price_idr > 0),
  "stock_qty" numeric(12,3) NOT NULL DEFAULT 0 CHECK (stock_qty >= 0),
  "unit" text NOT NULL DEFAULT 'kg',
  "image_urls" json,
  "published" boolean NOT NULL DEFAULT false,
  "created_at" timestamp with time zone NOT NULL DEFAULT NOW(),
  "updated_at" timestamp with time zone NOT NULL DEFAULT NOW()
);

-- Orders table
CREATE TABLE "orders" (
  "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "buyer_id" uuid NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  "status" order_status NOT NULL DEFAULT 'new',
  "subtotal_idr" bigint NOT NULL DEFAULT 0 CHECK (subtotal_idr >= 0),
  "shipping_fee_idr" bigint NOT NULL DEFAULT 0 CHECK (shipping_fee_idr >= 0),
  "total_idr" bigint NOT NULL DEFAULT 0 CHECK (total_idr >= 0),
  "shipping_address" json,
  "biteship_order_id" text,
  "biteship_reference_id" text,
  "courier_company" text,
  "courier_service" text,
  "tracking_number" text,
  "shipping_status" text,
  "midtrans_order_id" text,
  "midtrans_token" text,
  "payment_status" text,
  "paid_at" timestamp with time zone,
  "notes" text,
  "created_at" timestamp with time zone NOT NULL DEFAULT NOW(),
  "updated_at" timestamp with time zone NOT NULL DEFAULT NOW()
);

-- Order items table
CREATE TABLE "order_items" (
  "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "order_id" bigint NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  "product_id" bigint NOT NULL REFERENCES products(id) ON DELETE RESTRICT,
  "product_title" text NOT NULL,
  "price_idr" bigint NOT NULL CHECK (price_idr > 0),
  "qty" numeric(12,3) NOT NULL CHECK (qty > 0),
  "unit" text NOT NULL DEFAULT 'kg',
  "coffee_type" coffee_type,
  "grind_level" grind_level,
  "condition" condition,
  "image_url" text
);

-- Product reviews table
CREATE TABLE "product_reviews" (
  "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "product_id" bigint NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  "order_item_id" bigint NOT NULL REFERENCES order_items(id) ON DELETE CASCADE,
  "buyer_id" uuid NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  "rating" smallint NOT NULL CHECK (rating >= 1 AND rating <= 5),
  "comment" text,
  "created_at" timestamp with time zone NOT NULL DEFAULT NOW()
);

-- Cart items table (persistent cart storage)
CREATE TABLE cart_items (
  id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  product_id BIGINT NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  quantity NUMERIC(10,3) NOT NULL CHECK (quantity > 0),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Ensure one cart item per user-product combination
  UNIQUE(user_id, product_id)
);

-- Notifications table
CREATE TABLE notifications (
  id SERIAL PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  type notification_type NOT NULL,
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  data JSONB DEFAULT '{}',
  read BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Notification templates table
CREATE TABLE notification_templates (
  id SERIAL PRIMARY KEY,
  key TEXT UNIQUE NOT NULL,
  type notification_type NOT NULL,
  title_template TEXT NOT NULL,
  message_template TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Magazine posts table (enhanced with image support)
CREATE TABLE "magazine_posts" (
  "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "title" text NOT NULL,
  "slug" text UNIQUE,
  "summary" text,
  "content_md" text,
  "tags" json,
  "published" boolean NOT NULL DEFAULT false,
  "featured_image_url" TEXT,
  "gallery_images" JSON DEFAULT '[]'::json,
  "author_id" UUID REFERENCES profiles(id),
  "read_time_minutes" INTEGER DEFAULT 0,
  "excerpt" TEXT,
  "meta_description" TEXT,
  "view_count" INTEGER DEFAULT 0,
  "created_at" timestamp with time zone NOT NULL DEFAULT NOW(),
  "updated_at" timestamp with time zone NOT NULL DEFAULT NOW()
);

-- AI analyzer jobs table (optional audit trail)
CREATE TABLE "analyzer_jobs" (
  "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "product_id" bigint REFERENCES products(id) ON DELETE SET NULL,
  "buyer_id" uuid REFERENCES profiles(id) ON DELETE SET NULL,
  "images" json,
  "output" json,
  "created_at" timestamp with time zone NOT NULL DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX "idx_profiles_role" ON "profiles" ("role");
CREATE INDEX "idx_products_published" ON "products" ("published");
CREATE INDEX "idx_products_kind_category" ON "products" ("kind", "category");
CREATE INDEX "idx_products_ampas_attrs" ON "products" ("coffee_type", "grind_level", "condition");
CREATE INDEX "idx_orders_buyer" ON "orders" ("buyer_id");
CREATE INDEX "idx_orders_status" ON "orders" ("status");
CREATE INDEX "idx_order_items_order" ON "order_items" ("order_id");
CREATE INDEX "idx_order_items_product" ON "order_items" ("product_id");
CREATE UNIQUE INDEX "uq_reviews_order_item" ON "product_reviews" ("order_item_id");
CREATE INDEX "idx_reviews_product" ON "product_reviews" ("product_id");
CREATE INDEX "idx_reviews_buyer" ON "product_reviews" ("buyer_id");

-- Cart indexes
CREATE INDEX idx_cart_items_user_id ON cart_items(user_id);
CREATE INDEX idx_cart_items_product_id ON cart_items(product_id);
CREATE INDEX idx_cart_items_created_at ON cart_items(created_at);

-- Notification indexes
CREATE INDEX idx_notifications_user_id ON notifications(user_id);
CREATE INDEX idx_notifications_user_unread ON notifications(user_id, read) WHERE read = FALSE;
CREATE INDEX idx_notifications_type ON notifications(type);
CREATE INDEX idx_notifications_created_at ON notifications(created_at DESC);

-- Magazine indexes
CREATE INDEX "idx_magazine_published" ON "magazine_posts" ("published");
CREATE INDEX idx_magazine_author ON magazine_posts(author_id);
CREATE INDEX idx_magazine_created_at ON magazine_posts(created_at DESC);
CREATE INDEX idx_magazine_published_created ON magazine_posts(published, created_at DESC) WHERE published = true;
CREATE INDEX idx_magazine_tags ON magazine_posts USING GIN((tags::jsonb)) WHERE tags IS NOT NULL;
CREATE INDEX idx_magazine_search ON magazine_posts USING GIN(to_tsvector('english', title || ' ' || COALESCE(content_md, '') || ' ' || COALESCE(summary, ''))) WHERE published = true;

-- Product reviews indexes
CREATE INDEX IF NOT EXISTS idx_product_reviews_product_rating ON product_reviews(product_id, rating);
CREATE INDEX IF NOT EXISTS idx_product_reviews_created_at ON product_reviews(created_at);

-- Analyzer jobs indexes
CREATE INDEX "idx_analyzer_product" ON "analyzer_jobs" ("product_id");

-- Add comments for documentation
COMMENT ON TABLE "products" IS 'Business rules: If kind=ampas then category must be ampas_kopi. If kind=turunan then category cannot be ampas_kopi.';
COMMENT ON COLUMN "products"."price_idr" IS 'Price per unit (e.g., per kg) in Indonesian Rupiah';
COMMENT ON COLUMN "products"."stock_qty" IS 'Stock quantity in kg';
COMMENT ON COLUMN "products"."image_urls" IS 'Array of image URLs (JSON)';
COMMENT ON COLUMN "orders"."shipping_address" IS 'Snapshot of shipping address and Biteship details';
COMMENT ON COLUMN "orders"."biteship_reference_id" IS 'Reference ID for Biteship webhook tracking (format: SIKUPI-SHIP-{timestamp}-{random}-{order_id})';
COMMENT ON COLUMN "order_items"."product_title" IS 'Snapshot of product title at time of order';
COMMENT ON COLUMN "order_items"."qty" IS 'Quantity in kg';
COMMENT ON COLUMN "product_reviews"."rating" IS 'Rating from 1 to 5';
COMMENT ON COLUMN "magazine_posts"."tags" IS 'Array of tags (JSON)';
COMMENT ON COLUMN "magazine_posts"."featured_image_url" IS 'Main featured image URL for the post (Supabase Storage)';
COMMENT ON COLUMN "magazine_posts"."gallery_images" IS 'Array of additional image URLs (JSON)';
COMMENT ON COLUMN "magazine_posts"."author_id" IS 'Admin user who created the post';
COMMENT ON COLUMN "magazine_posts"."read_time_minutes" IS 'Estimated reading time in minutes';
COMMENT ON COLUMN "magazine_posts"."excerpt" IS 'Short excerpt for listings (auto-generated from content if empty)';
COMMENT ON COLUMN "magazine_posts"."meta_description" IS 'SEO meta description (max 160 chars)';
COMMENT ON COLUMN "magazine_posts"."view_count" IS 'Number of times the post has been viewed';
COMMENT ON COLUMN "analyzer_jobs"."images" IS 'Array of input image URLs';
COMMENT ON COLUMN "analyzer_jobs"."output" IS 'AI analysis output: {coffee_type, grind_level, price_min_idr, model_version, ...}';
COMMENT ON TABLE "notifications" IS 'User notifications for real-time updates';
COMMENT ON TABLE "notification_templates" IS 'Reusable notification templates with placeholders';
COMMENT ON TABLE "cart_items" IS 'Persistent cart storage replacing in-memory cart';

-- Create trigger function for updating updated_at timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for updated_at
CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_products_updated_at BEFORE UPDATE ON products FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_orders_updated_at BEFORE UPDATE ON orders FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_cart_items_updated_at BEFORE UPDATE ON cart_items FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_magazine_posts_updated_at BEFORE UPDATE ON magazine_posts FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_notifications_updated_at BEFORE UPDATE ON notifications FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Enable RLS on all tables
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE cart_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE magazine_posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE analyzer_jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- Function to check if user is admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM profiles
    WHERE id = auth.uid()
    AND role = 'admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RLS Policies
-- Profiles policies
CREATE POLICY "profiles_select_own" ON profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "profiles_update_own" ON profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "profiles_insert_own" ON profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "profiles_admin_all" ON profiles FOR ALL USING (is_admin());

-- Products policies
CREATE POLICY "products_select_published" ON products FOR SELECT USING (published = true);
CREATE POLICY "products_admin_all" ON products FOR ALL USING (is_admin());

-- Orders policies
CREATE POLICY "orders_select_own" ON orders FOR SELECT USING (buyer_id = auth.uid());
CREATE POLICY "orders_insert_own" ON orders FOR INSERT WITH CHECK (buyer_id = auth.uid());
CREATE POLICY "orders_update_own" ON orders FOR UPDATE USING (buyer_id = auth.uid()) WITH CHECK (buyer_id = auth.uid());
CREATE POLICY "orders_admin_all" ON orders FOR ALL USING (is_admin());

-- Order items policies
CREATE POLICY "order_items_select_own" ON order_items FOR SELECT USING (
  EXISTS (SELECT 1 FROM orders WHERE orders.id = order_items.order_id AND orders.buyer_id = auth.uid())
);
CREATE POLICY "order_items_insert_own" ON order_items FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM orders WHERE orders.id = order_items.order_id AND orders.buyer_id = auth.uid())
);
CREATE POLICY "order_items_admin_all" ON order_items FOR ALL USING (is_admin());

-- Product reviews policies
CREATE POLICY "product_reviews_select_all" ON product_reviews FOR SELECT USING (true);
CREATE POLICY "product_reviews_insert_own" ON product_reviews FOR INSERT WITH CHECK (
  buyer_id = auth.uid() AND
  EXISTS (
    SELECT 1 FROM order_items
    JOIN orders ON orders.id = order_items.order_id
    WHERE order_items.id = order_item_id
    AND orders.buyer_id = auth.uid()
    AND orders.status = 'completed'
  )
);
CREATE POLICY "product_reviews_update_own" ON product_reviews FOR UPDATE USING (buyer_id = auth.uid()) WITH CHECK (buyer_id = auth.uid());
CREATE POLICY "product_reviews_delete_own" ON product_reviews FOR DELETE USING (buyer_id = auth.uid());

-- Cart items policies
CREATE POLICY "Users can manage their own cart items" ON cart_items FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Service role has full access" ON cart_items FOR ALL USING (auth.role() = 'service_role');

-- Magazine posts policies
CREATE POLICY "Public can view published magazine posts" ON magazine_posts FOR SELECT TO public USING (published = true);
CREATE POLICY "Admins can manage all magazine posts" ON magazine_posts FOR ALL TO authenticated USING (
  EXISTS (SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.role = 'admin')
);

-- Analyzer jobs policies
CREATE POLICY "analyzer_jobs_select_own" ON analyzer_jobs FOR SELECT USING (buyer_id = auth.uid());
CREATE POLICY "analyzer_jobs_insert_own" ON analyzer_jobs FOR INSERT WITH CHECK (buyer_id = auth.uid() OR buyer_id IS NULL);
CREATE POLICY "analyzer_jobs_admin_all" ON analyzer_jobs FOR ALL USING (is_admin());

-- Notification policies
CREATE POLICY "notifications_select_own" ON notifications FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "notifications_update_own" ON notifications FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "notifications_insert_admin" ON notifications FOR INSERT WITH CHECK (
  auth.uid() IS NOT NULL AND 
  EXISTS (
    SELECT 1 FROM profiles 
    WHERE id = auth.uid() 
    AND role = 'admin'
  )
);
CREATE POLICY "notifications_admin_read_all" ON notifications FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM profiles 
    WHERE id = auth.uid() 
    AND role = 'admin'
  )
);

-- Views
CREATE OR REPLACE VIEW product_listings AS
SELECT 
  p.*,
  COALESCE(stats.review_count, 0) as review_count,
  COALESCE(stats.avg_rating, 0) as avg_rating
FROM products p
LEFT JOIN LATERAL (
  SELECT 
    COUNT(*) as review_count,
    AVG(rating) as avg_rating
  FROM product_reviews pr
  WHERE pr.product_id = p.id
) stats ON true
WHERE p.published = true;

CREATE VIEW cart_with_products AS
SELECT 
  ci.id,
  ci.user_id,
  ci.product_id,
  ci.quantity,
  ci.created_at,
  ci.updated_at,
  p.title as product_title,
  p.price_idr,
  p.stock_qty,
  p.unit,
  p.coffee_type,
  p.grind_level,
  p.condition,
  p.image_urls,
  (ci.quantity * p.price_idr) as subtotal_idr
FROM cart_items ci
JOIN products p ON ci.product_id = p.id
WHERE p.published = true;

CREATE OR REPLACE VIEW product_rating_summary AS
SELECT 
  p.id as product_id,
  p.title,
  p.published,
  COALESCE(COUNT(pr.id), 0) as total_reviews,
  COALESCE(ROUND(AVG(pr.rating), 1), 0) as avg_rating,
  COALESCE(COUNT(CASE WHEN pr.rating = 5 THEN 1 END), 0) as five_stars,
  COALESCE(COUNT(CASE WHEN pr.rating = 4 THEN 1 END), 0) as four_stars,
  COALESCE(COUNT(CASE WHEN pr.rating = 3 THEN 1 END), 0) as three_stars,
  COALESCE(COUNT(CASE WHEN pr.rating = 2 THEN 1 END), 0) as two_stars,
  COALESCE(COUNT(CASE WHEN pr.rating = 1 THEN 1 END), 0) as one_star,
  MAX(pr.created_at) as latest_review_date
FROM products p
LEFT JOIN product_reviews pr ON p.id = pr.product_id
GROUP BY p.id, p.title, p.published;

-- Grant access to views
GRANT SELECT ON product_rating_summary TO anon, authenticated;

-- Magazine helper functions
CREATE OR REPLACE FUNCTION generate_magazine_slug(post_title TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN lower(
    regexp_replace(
      regexp_replace(
        regexp_replace(post_title, '[^a-zA-Z0-9\s-]', '', 'g'),
        '\s+', '-', 'g'
      ),
      '-+', '-', 'g'
    )
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION estimate_reading_time(content TEXT)
RETURNS INTEGER AS $$
DECLARE
  word_count INTEGER;
BEGIN
  word_count := array_length(string_to_array(trim(content), ' '), 1);
  RETURN GREATEST(1, ROUND(word_count / 200.0));
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION generate_excerpt(content TEXT, max_length INTEGER DEFAULT 200)
RETURNS TEXT AS $$
DECLARE
  plain_text TEXT;
  excerpt TEXT;
BEGIN
  plain_text := regexp_replace(content, '#{1,6}\s+', '', 'g');
  plain_text := regexp_replace(plain_text, '\*\*(.*?)\*\*', '\1', 'g');
  plain_text := regexp_replace(plain_text, '\*(.*?)\*', '\1', 'g');
  plain_text := regexp_replace(plain_text, '\[(.*?)\]\(.*?\)', '\1', 'g');
  plain_text := regexp_replace(plain_text, '`(.*?)`', '\1', 'g');
  plain_text := regexp_replace(plain_text, '\n+', ' ', 'g');
  plain_text := trim(plain_text);
  
  IF length(plain_text) > max_length THEN
    excerpt := substring(plain_text from 1 for max_length);
    excerpt := substring(excerpt from 1 for length(excerpt) - position(' ' in reverse(excerpt)));
    excerpt := excerpt || '...';
  ELSE
    excerpt := plain_text;
  END IF;
  
  RETURN excerpt;
END;
$$ LANGUAGE plpgsql;

-- Magazine auto-fields trigger
CREATE OR REPLACE FUNCTION magazine_posts_auto_fields()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.slug IS NULL OR NEW.slug = '' THEN
    NEW.slug := generate_magazine_slug(NEW.title);
    
    WHILE EXISTS (SELECT 1 FROM magazine_posts WHERE slug = NEW.slug AND id != COALESCE(NEW.id, 0)) LOOP
      NEW.slug := NEW.slug || '-' || extract(epoch from now())::text;
    END LOOP;
  END IF;
  
  IF NEW.content_md IS NOT NULL THEN
    NEW.read_time_minutes := estimate_reading_time(NEW.content_md);
  END IF;
  
  IF (NEW.excerpt IS NULL OR NEW.excerpt = '') AND NEW.content_md IS NOT NULL THEN
    NEW.excerpt := generate_excerpt(NEW.content_md, 200);
  END IF;
  
  NEW.updated_at := now();
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS magazine_posts_auto_fields_trigger ON magazine_posts;
CREATE TRIGGER magazine_posts_auto_fields_trigger
  BEFORE INSERT OR UPDATE ON magazine_posts
  FOR EACH ROW
  EXECUTE FUNCTION magazine_posts_auto_fields();

-- Business logic functions (RPC)
CREATE OR REPLACE FUNCTION create_product_review(
  p_order_item_id bigint,
  p_rating integer,
  p_comment text DEFAULT NULL
)
RETURNS json AS $$
DECLARE
  v_buyer_id uuid;
  v_product_id bigint;
  v_order_status order_status;
  v_existing_review_id bigint;
  v_review_id bigint;
BEGIN
  v_buyer_id := auth.uid();
  
  IF v_buyer_id IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;
  
  IF p_rating < 1 OR p_rating > 5 THEN
    RAISE EXCEPTION 'Rating must be between 1 and 5';
  END IF;
  
  SELECT o.status, oi.product_id INTO v_order_status, v_product_id
  FROM order_items oi
  JOIN orders o ON o.id = oi.order_id
  WHERE oi.id = p_order_item_id AND o.buyer_id = v_buyer_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Order item not found or access denied';
  END IF;
  
  IF v_order_status != 'completed' THEN
    RAISE EXCEPTION 'Reviews can only be created for completed orders';
  END IF;
  
  SELECT id INTO v_existing_review_id FROM product_reviews WHERE order_item_id = p_order_item_id;
  
  IF FOUND THEN
    RAISE EXCEPTION 'Review already exists for this order item';
  END IF;
  
  INSERT INTO product_reviews (product_id, order_item_id, buyer_id, rating, comment) 
  VALUES (v_product_id, p_order_item_id, v_buyer_id, p_rating, p_comment) 
  RETURNING id INTO v_review_id;
  
  RETURN json_build_object('success', true, 'review_id', v_review_id, 'message', 'Review created successfully');
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION get_product_stats(p_product_id bigint)
RETURNS json AS $$
DECLARE
  v_stats record;
BEGIN
  SELECT 
    COUNT(*) as review_count,
    COALESCE(AVG(rating), 0) as avg_rating,
    COALESCE(MIN(rating), 0) as min_rating,
    COALESCE(MAX(rating), 0) as max_rating
  INTO v_stats
  FROM product_reviews
  WHERE product_id = p_product_id;
  
  RETURN json_build_object(
    'review_count', v_stats.review_count,
    'avg_rating', ROUND(v_stats.avg_rating, 2),
    'min_rating', v_stats.min_rating,
    'max_rating', v_stats.max_rating
  );
END;
$$ LANGUAGE plpgsql;

-- Updated create_order_with_items function (from fix_stored_procedure.sql)
CREATE OR REPLACE FUNCTION create_order_with_items(
  p_buyer_id uuid,
  p_items json,
  p_shipping_address json,
  p_shipping_fee_idr bigint DEFAULT 0,
  p_courier_company text DEFAULT NULL,
  p_courier_service text DEFAULT NULL,
  p_notes text DEFAULT NULL
)
RETURNS json AS $$
DECLARE
  v_order_id bigint;
  v_item record;
  v_subtotal_idr bigint := 0;
  v_total_idr bigint;
  v_product_price bigint;
  v_product_title text;
  v_product_stock numeric;
BEGIN
  INSERT INTO orders (
    buyer_id, status, subtotal_idr, shipping_fee_idr, total_idr,
    shipping_address, courier_company, courier_service, notes
  ) VALUES (
    p_buyer_id, 'new', 0, p_shipping_fee_idr, 0,
    p_shipping_address, p_courier_company, p_courier_service, p_notes
  ) RETURNING id INTO v_order_id;
  
  FOR v_item IN 
    SELECT * FROM json_to_recordset(p_items) AS items(
      product_id bigint, quantity numeric, coffee_type text, grind_level text, condition text
    )
  LOOP
    SELECT title, price_idr, stock_qty INTO v_product_title, v_product_price, v_product_stock
    FROM products WHERE id = v_item.product_id AND published = true;
    
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Product not found or not published: %', v_item.product_id;
    END IF;
    
    IF v_product_stock < v_item.quantity THEN
      RAISE EXCEPTION 'Insufficient stock for product ID: %. Available: %, Requested: %', 
        v_item.product_id, v_product_stock, v_item.quantity;
    END IF;
    
    INSERT INTO order_items (
      order_id, product_id, product_title, price_idr, qty, unit,
      coffee_type, grind_level, condition, image_url
    ) SELECT 
      v_order_id, v_item.product_id, v_product_title, v_product_price,
      v_item.quantity, 'kg',
      COALESCE(v_item.coffee_type::coffee_type, p.coffee_type),
      COALESCE(v_item.grind_level::grind_level, p.grind_level),
      COALESCE(v_item.condition::condition, p.condition),
      CASE WHEN p.image_urls IS NOT NULL AND json_array_length(p.image_urls) > 0 
           THEN p.image_urls->>0 ELSE NULL END
    FROM products p WHERE p.id = v_item.product_id;
    
    v_subtotal_idr := v_subtotal_idr + (v_product_price * v_item.quantity);
    
    UPDATE products SET stock_qty = stock_qty - v_item.quantity, updated_at = NOW()
    WHERE id = v_item.product_id;
  END LOOP;
  
  v_total_idr := v_subtotal_idr + p_shipping_fee_idr;
  
  UPDATE orders SET subtotal_idr = v_subtotal_idr, total_idr = v_total_idr, updated_at = NOW()
  WHERE id = v_order_id;
  
  RETURN json_build_object('success', true, 'order_id', v_order_id, 'subtotal_idr', v_subtotal_idr, 'total_idr', v_total_idr);
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Notification management functions
CREATE OR REPLACE FUNCTION create_notification(
  p_user_id UUID,
  p_type notification_type,
  p_title TEXT,
  p_message TEXT,
  p_data JSONB DEFAULT '{}'
) RETURNS INTEGER AS $$
DECLARE
  notification_id INTEGER;
  user_validation RECORD;
BEGIN
  -- Validate user first
  SELECT * INTO user_validation
  FROM public.validate_user_for_notifications(p_user_id);
  
  IF NOT user_validation.valid THEN
    RAISE WARNING 'Notification creation failed for user %: %', p_user_id, user_validation.error_message;
    RETURN NULL;
  END IF;
  
  -- Create notification
  INSERT INTO notifications (user_id, type, title, message, data)
  VALUES (p_user_id, p_type, p_title, p_message, p_data)
  RETURNING id INTO notification_id;
  
  RAISE LOG 'Notification % created for user % (role: %)', notification_id, p_user_id, user_validation.role;
  
  RETURN notification_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION mark_notification_read(notification_id INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
  UPDATE notifications 
  SET read = TRUE, updated_at = NOW()
  WHERE id = notification_id AND user_id = auth.uid();
  
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION mark_all_notifications_read()
RETURNS INTEGER AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  UPDATE notifications 
  SET read = TRUE, updated_at = NOW()
  WHERE user_id = auth.uid() AND read = FALSE;
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION get_unread_notification_count()
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM notifications 
    WHERE user_id = auth.uid() AND read = FALSE
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION cleanup_old_notifications()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM notifications 
  WHERE created_at < NOW() - INTERVAL '30 days';
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Insert common notification templates
INSERT INTO notification_templates (key, type, title_template, message_template) VALUES
('order_created', 'order_update', 'Pesanan Baru #{order_id}', 'Pesanan Anda telah berhasil dibuat. Total: Rp {total}'),
('payment_confirmed', 'payment_confirmed', 'Pembayaran Berhasil! ✅', 'Pembayaran untuk pesanan #{order_id} telah dikonfirmasi. Pesanan akan segera diproses.'),
('order_packed', 'order_update', 'Pesanan Dikemas 📦', 'Pesanan #{order_id} sudah dikemas dan siap dikirim.'),
('order_shipped', 'shipment_ready', 'Paket Dikirim 🚚', 'Pesanan #{order_id} telah dikirim via {courier}. Nomor resi: {tracking_number}'),
('order_completed', 'order_update', 'Pesanan Selesai 🎉', 'Pesanan #{order_id} telah selesai. Terima kasih sudah berbelanja di Sikupi!'),
('ai_analysis_complete', 'ai_analysis', 'Analisis AI Selesai 🤖', 'Hasil analisis ampas kopi Anda sudah siap. Sikupi Score: {score}/100'),
('admin_new_order', 'admin_alert', 'Pesanan Baru Masuk', '{customer_name} membuat pesanan #{order_id} - Total: Rp {total}'),
('admin_low_stock', 'admin_alert', 'Stok Menipis ⚠️', 'Produk {product_name} tersisa {stock} unit');

-- Grant necessary permissions for service role and functions
GRANT USAGE ON SCHEMA public TO service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO service_role;
GRANT EXECUTE ON FUNCTION public.handle_new_user(UUID, TEXT, TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION public.validate_user_for_notifications(UUID) TO service_role;

-- Auth profile management functions
CREATE OR REPLACE FUNCTION public.handle_new_user(p_user_id UUID, p_email TEXT DEFAULT NULL, p_full_name TEXT DEFAULT NULL)
RETURNS BOOLEAN AS $$
DECLARE
  profile_exists BOOLEAN;
BEGIN
  -- Check if profile already exists
  SELECT EXISTS(
    SELECT 1 FROM public.profiles WHERE id = p_user_id
  ) INTO profile_exists;
  
  IF profile_exists THEN
    RAISE LOG 'Profile already exists for user: %', p_user_id;
    RETURN FALSE;
  END IF;
  
  -- Insert new profile for the user with default buyer role
  INSERT INTO public.profiles (id, full_name, role, created_at, updated_at)
  VALUES (
    p_user_id,
    COALESCE(p_full_name, 'New User'),
    'buyer',
    NOW(),
    NOW()
  );
  
  -- Log the profile creation
  RAISE LOG 'Profile created for user: % (%)', p_user_id, COALESCE(p_email, 'unknown email');
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.validate_user_for_notifications(p_user_id UUID)
RETURNS TABLE(
  valid BOOLEAN,
  user_exists BOOLEAN,
  profile_exists BOOLEAN,
  has_role BOOLEAN,
  role TEXT,
  error_message TEXT
) AS $$
DECLARE
  auth_user_exists BOOLEAN := FALSE;
  profile_record RECORD;
BEGIN
  -- Check if user exists in auth.users
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE id = p_user_id
  ) INTO auth_user_exists;
  
  IF NOT auth_user_exists THEN
    valid := FALSE;
    user_exists := FALSE;
    profile_exists := FALSE;
    has_role := FALSE;
    role := NULL;
    error_message := 'User does not exist in auth system';
    RETURN NEXT;
    RETURN;
  END IF;
  
  -- Check profile and role
  SELECT p.id, p.role 
  INTO profile_record
  FROM public.profiles p 
  WHERE p.id = p_user_id;
  
  IF profile_record IS NULL THEN
    valid := FALSE;
    user_exists := TRUE;
    profile_exists := FALSE;
    has_role := FALSE;
    role := NULL;
    error_message := 'User has no profile - notifications disabled';
    RETURN NEXT;
    RETURN;
  END IF;
  
  -- User and profile are valid
  valid := TRUE;
  user_exists := TRUE;
  profile_exists := TRUE;
  has_role := TRUE;
  role := profile_record.role;
  error_message := NULL;
  RETURN NEXT;
  
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cart management functions
CREATE OR REPLACE FUNCTION get_cart_statistics()
RETURNS JSON AS $$
DECLARE
  total_users INTEGER;
  total_items BIGINT;
  avg_value NUMERIC;
BEGIN
  SELECT COUNT(DISTINCT user_id) INTO total_users FROM cart_items;
  SELECT COUNT(*) INTO total_items FROM cart_items;
  SELECT COALESCE(AVG(cart_value), 0) INTO avg_value
  FROM (
    SELECT SUM(ci.quantity * p.price_idr) as cart_value
    FROM cart_items ci
    JOIN products p ON ci.product_id = p.id
    GROUP BY ci.user_id
  ) cart_values;
  
  RETURN json_build_object(
    'total_users_with_carts', total_users,
    'total_cart_items', total_items,
    'average_cart_value', ROUND(avg_value, 0)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION cleanup_abandoned_carts(
  days_old INTEGER DEFAULT 30,
  dry_run BOOLEAN DEFAULT true
)
RETURNS JSON AS $$
DECLARE
  deleted_count INTEGER;
  affected_users INTEGER;
BEGIN
  IF dry_run THEN
    SELECT COUNT(*) INTO deleted_count
    FROM cart_items WHERE updated_at < (NOW() - INTERVAL '1 day' * days_old);
    
    SELECT COUNT(DISTINCT user_id) INTO affected_users
    FROM cart_items WHERE updated_at < (NOW() - INTERVAL '1 day' * days_old);
    
    RETURN json_build_object(
      'dry_run', true,
      'would_delete_items', deleted_count,
      'would_affect_users', affected_users,
      'cutoff_date', (NOW() - INTERVAL '1 day' * days_old)
    );
  ELSE
    DELETE FROM cart_items WHERE updated_at < (NOW() - INTERVAL '1 day' * days_old);
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    RETURN json_build_object(
      'dry_run', false,
      'deleted_items', deleted_count,
      'cutoff_date', (NOW() - INTERVAL '1 day' * days_old)
    );
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;